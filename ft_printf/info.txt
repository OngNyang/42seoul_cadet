주의사항
	- 원본의 버퍼관리는 구현하지 말기
	- cspdiuxX% 처리할수 있어야함
	- makefile에서 ar 커맨드 사용

공부해야할 개념
	- va_list
		: 가변인자. 변수가 몇개 들어올지 모를때 사용할수 있다.
		- va_list 라는 데이터타입을 사용.
		- ... 키워드 사용
		- stdarg.h에 정의 되어있다.
		- va_start, va_arg, va_copy등의 함수가 있다.
		관련 함수
			- va_start
				: va_list 를 초기화
				#define va_start(ap, v) ( (ap) = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v))
				//va_list 변수 ap의 주소 값에다가 고정파라미터(가변 파라미터 이외에 최소 1개의 고정 파라미터가 필요하다) 크기를 더한 위치로 ap를 초기화
			- va_arg
				: ap포인터가 위치한 부분의 데이터를 읽어 반환. 그 후 포인터 증가 시킴.
				- va_arg(변수, 데이터타입);
				#define va_arg(ap, t) (*(t*))((ap += _INTSIZEOF(t)) - _INTSIZEOF(t))
			- va_end
				:va_list 타입의 변수를 NULL로 초기화.

printf()
	- 첫번째 매개변수로 문자열
	- 그후 가변인자로 n개의 매개변수를 받음.
	- return value
		출력된 문자열의 수(최후의 널문자까지 포함)
		리턴 타입은 int이다. 따라서, 크기를 셀때 int 변수로 세어주면 된다.
	- 옵션
		%u : 부호 없는 정수로 출력해야 하는데 예를들면, 음수가 들어오면, 오버플로된 값이 나오는것이 정상
		%i : signed int. printf의 경우 %d와 차이가 없다.
			 하지만 scanf인 경우 이 둘은 다르다.%d는 10진법으로 받고, %i는 진법을 자동 탐색한다.
		%p : void* 포인터는 16진법으로 출력되어야 한다.
			 0x를 출력해야 함.
			 출력 사이즈는 상당히 커야함.
			 	메모리 주소를 사용하는 데이터 타입은 unsigned long.
				cpu 아키텍쳐에 따라 메모리 주소의 크기도 달라지는데, unsigned long은 그에 맞게 변할수 있다.
		%x,X : hexa decimal로 출력하는데, unsigned int로 들어올수도 있기에 적절한 처리를 해줘야 한다.

어려웠던 점
	- va_arg를 사용하면, va_list의 변수가 자동으로 다음 주소로 변한다고 알고는 있었는데 
	  이 변수를 또다른 헬퍼함수의 파라미터로 쓸때, 움직이질 않았다.
	  결과적으로, 이변수의 주소 즉 주소의 주소를 넘겨주어야 움직였다.
	- %i는 unsigned int로 받아서 출력을 해주면 되는데, 음수가 없다.